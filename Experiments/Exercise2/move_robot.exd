#!/usr/bin/env python

import hbp_nrp_excontrol.nrp_states as states
from hbp_nrp_excontrol.nrp_states import SetModelPose
from hbp_nrp_excontrol.logs import clientLogger
import smach
from smach import StateMachine, CBState
import rospy
from gazebo_msgs.msg import ModelStates
from geometry_msgs.msg import Vector3
import numpy as np
import csv

FINISHED = 'FINISHED'
ERROR = 'ERROR'
PREEMPTED = 'PREEMPTED'
# State machine initialization
sm = StateMachine(outcomes=[FINISHED, ERROR, PREEMPTED])

# Userdata allows to variables accross states
sm.userdata.state = np.array([0.,0.])
sm.userdata.trap_counter = 0
sm.userdata.trap_state = None

def check_trap():
    @smach.cb_interface(input_keys=['trap_counter', 'trap_state', 'state'],
                        output_keys=['trap_counter', 'trap_state'],
                        outcomes=['valid', 'invalid'])
    def check(userdata):
        if userdata.trap_counter == 0:
            userdata.trap_state = userdata.state.copy()
            userdata.trap_counter += 1
            return 'invalid'
        else:
            if np.linalg.norm(userdata.state - userdata.trap_state) > 0.05:
                userdata.trap_state = None
                userdata.trap_counter = 0
                return 'invalid'
            else:
                userdata.trap_counter += 1 
                if userdata.trap_counter < 10:
                    return 'invalid'
                else:
                    userdata.trap_state = None
                    userdata.trap_counter = 0
                    return 'valid'
    return check

def new_spawn():
    x = np.random.choice([-4., 4.])
    y = np.random.choice([-4., 4.])
    theta = -np.sign(y) * np.pi / 4.
    if x != -4.:
        theta *= 3.
    return SetModelPose('robot', Vector3(x, y, 0.1), Vector3(0., 0., theta), Vector3(1., 1., 1.))

with sm:
 
    # Verify wether the robot is trapped/stucked somewhere or not
    StateMachine.add("check_trap",
                     CBState(check_trap()),
                     transitions = {"valid": "new_spawn",
                                    "invalid": "check_wait"})
    
    # Wait 1sec before checking again
    StateMachine.add("check_wait",
                     states.ClockDelayState(1),
                     transitions = {"valid": "check_wait",
                                    "invalid": "check_trap",
                                    "preempted": PREEMPTED})
    # Displace the robot in a new position
    StateMachine.add("new_spawn",
                     new_spawn(),
                     transitions = {"succeeded": 'check_wait',
                                    "preempted": PREEMPTED,
                                    "aborted": ERROR})
